# **phResume：最终开发路线图 (v3)**

本文档是项目的核心开发蓝图，它整合了所有已完成的架构（Phase 0-4）和即将开发的编辑器功能（Phase 5），并以 CI/CD (Phase 6\) 收尾。

## **地基 (Foundation) \- (已完成)**

### **Phase 0: 环境与地基搭建**

* **状态：** ✅ 已完成  
* **成果：** docker-compose.yml 成功运行 api, frontend, db, nginx 服务。

### **Phase 1: 核心功能 MVP**

* **状态：** ✅ 已完成  
* **成果：** 实现了 go-rod 的同步 PDF 生成（后被 Phase 2 重构），并解决了字体（wqy-zenhei）和 chromium 依赖问题。

### **Phase 2: 异步处理与文件存储**

* **状态：** ✅ 已完成  
* **成果：** api 重构为异步（Asynq），worker 服务被创建。Redis (消息队列) 和 MinIO (对象存储) 成功集成。

### **Phase 3: 认证与实时通知**

* **状态：** ✅ 已完成  
* **成果：**  
  * api 实现了完整的 JWT (RS256) 认证（登录/注册/刷新/退出）。  
  * resume 路由被 AuthMiddleware 保护。  
  * 实现了 WebSocket \+ Redis Pub/Sub 的实时通知闭环。  
  * 实现了**私有 Bucket \+ 预签名 URL**（Presigned URL）的安全文件下载架构。

### **Phase 4: 可观测性与安全**

* **状态：** ✅ 已完成  
* **成果：**  
  * Loki \+ Promtail 成功收集 api, worker, nginx 的日志。  
  * Prometheus \+ Grafana 成功收集并展示了 api 和 worker 的自定义指标。  
  * ClamAV 服务已在 docker-compose 中“预配置”并注入 api 配置。

## **Phase 5: 编辑器 (The Editor) \- (当前阶段)**

这是项目的核心功能阶段。我们将用一个“所见即所得”的网格编辑器替换掉 Phase 1 的 \<textarea\>。

**核心技术决策：**

* **布局引擎：** react-grid-layout (前端) \+ CSS Grid (后端 Go 模板)  
* **网格系统：** 24 列 (相对宽度)  
* **行高：** 10 像素 (绝对高度单位)  
* **数据契约：** JSONB (取代 string)

### **Phase 5.0: 核心重构 (数据契约变更)**

**目标：** 将后端的数据存储从 string 彻底重构为 JSONB，为新的网格布局编辑器奠定数据基础。

1. **后端 (Database):**  
   * 修改 backend/internal/database/models.go。  
   * 将 Resume 模型中的 Content string 字段修改为 Content datatypes.JSONB (GORM 标签: type:jsonb)。  
   * 运行 AutoMigrate (通过重启 api 服务) 以应用数据库表结构变更。  
2. **后端 (API):**  
   * 修改 backend/internal/api/resume\_handler.go 中的 CreateResume。它现在必须能接收并保存一个完整的 JSON 对象（c.ShouldBindJSON），而不仅仅是 { "content": "..." }。  
   * 实现 GET /v1/resume/latest 路由（受 AuthMiddleware 保护），用于加载用户最新的简历 JSON 数据。  
3. **前端 (Editor MVP v2):**  
   * 在 frontend/app/page.tsx 中，移除 Phase 1 的 \<textarea\>。  
   * （可选，用于测试）添加一个临时的 JSON 编辑器 (如 react-json-editor-ajrm)，使其能够加载和保存 JSON 数据。  
4. **状态（Acknowledge）：**  
   * **此步骤会暂时“弄坏”PDF 生成功能**。worker（pdf\_handler.go）仍然期望 Content 是 string。我们**接受** worker 在此阶段会失败，并在 Phase 5.4 中修复它。

**验收标准：** 前端可以从 GET /v1/resume/latest 加载 JSON，修改它，并通过 POST /v1/resume 成功地将其保存回 JSONB 字段。

### **Phase 5.1: 网格布局 (Visual Layout)**

**目标：** 引入 react-grid-layout，实现“所见”的核心——让用户能够拖动和调整模块大小。

1. **前端 (依赖)：**  
   * npm install react-grid-layout react-resizable @types/react-grid-layout @types/react-resizable。  
2. **前端 (Editor UI):**  
   * 在 frontend/app/page.tsx 中，导入并渲染 \<ReactGridLayout\> 组件。  
   * **配置：** cols={24}, rowHeight={10}。  
   * **A4 画布：** 创建一个 \<PageContainer\> 组件，使用 aspect-ratio: 210 / 297; 和固定 width (如 900px) 来模拟 A4 纸。  
3. **前端 (State)：**  
   * 从后端加载的 JSON（现在包含 items 数组和 layout 字段）需要被正确地映射到 layout 状态。  
4. **前端 (交互)：**  
   * 实现 onLayoutChange 回调。当用户在前端**拖动**或**调整大小**一个模块时，此回调被触发。  
   * 你**必须**在此回调中**更新**你的 React JSON 状态，以保存新的 (x, y, w, h) 坐标。

**验收标准：** 用户可以在浏览器中拖动布局模块，调整它们的大小，并且在**刷新页面**（从后端重新加载 JSON）后，布局保持不变。

### **Phase 5.2: 内容编辑与样式微调**

**目标：** 让用户不仅能“移动”模块，还能“编辑”模块内的文本内容和样式。

1. **前端 (UI \- 内容)：**  
   * \<ReactGridLayout\> 中的每个子 \<div\>（网格项）现在是一个自定义组件（例如 TextItem）。  
   * 使用 react-contenteditable 库实现“在位编辑”。  
   * 当 onBlur (失焦) 时，捕获新的 content 字符串，并**更新** React JSON 状态中对应 item 的 content 字段。  
2. **后端 (Data Contract):**  
   * 在 JSONB 结构中正式添加 layout\_settings 对象（如 accent\_color, font\_family, font\_size\_pt, margin\_px）。  
3. **前端 (UI \- 样式)：**  
   * 创建一个新的 StylePanel.tsx 组件（侧边栏）。  
   * 添加 HTML 控件：字体选择 (\<select\>)、主题色 (\<input type="color"\>)、字体大小 (\<input type="range"\>)。  
4. **前端 (Live Preview):**  
   * StylePanel 控件的 onChange 事件**立即**更新 React JSON 状态中的 layout\_settings 对象。  
   * A4 画布 (\<PageContainer\>) 和网格项 (\<TextItem\>) 的样式**必须**动态地从 layout\_settings 状态中读取，实现**实时预览**。

**验收标准：** 用户可以点击简历预览中的文本进行修改，也可以在样式面板中拖动滑块，A4 画布预览**实时**发生变化。

### **Phase 5.3: 新元素 (图片与分割线)**

**目标：** 扩展编辑器功能，允许用户添加非文本元素。

1. **后端 (API \- 文件上传):**  
   * 实现 POST /v1/assets/upload 路由（受 AuthMiddleware 保护）。  
   * **安全：** 处理器**必须**将上传的文件流**转发到 ClamAV** (CLAMAV\_HOST) 进行扫描。  
   * **存储：** 如果扫描安全，使用 storage.Client (internalClient.PutObject) 将文件上传到 MinIO。  
   * **响应：** 返回 objectKey (例如 user-assets/123/image.png)。  
2. **后端 (API \- 文件查看):**  
   * 实现 GET /v1/assets/view 路由（受 AuthMiddleware 保护）。  
   * 接收 key (objectKey) 作为查询参数。  
   * 调用 storage.Client.GeneratePresignedURL 返回一个临时的、安全的 URL。  
3. **前端 (UI):**  
   * 在工具栏上添加“添加图片”和“添加分割线”按钮。  
4. **前端 (交互 \- 分割线):**  
   * 点击按钮，向 items 状态数组中 push 一个新的 item 对象：  
     { "id": "...", "type": "divider", "style": {...}, "layout": {...} }  
5. **前端 (交互 \- 图片):**  
   * 点击按钮，触发文件上传 (\<input type="file"\>)。  
   * 调用 POST /v1/assets/upload 上传图片，获取 objectKey。  
   * 向 items 状态数组中 push 一个新的 item 对象：  
     { "id": "...", "type": "image", "content": "objectKey-string", "style": {...}, "layout": {...} }  
6. **前端 (渲染):**  
   * 重构 page.tsx 的渲染逻辑，使其能够 map items 数组，并根据 item.type 渲染不同的组件 (\<TextItem\>, \<DividerItem\>, \<ImageItem\>)。  
   * ImageItem 组件**必须**使用 useEffect \+ fetch 来调用 GET /v1/assets/view，以获取它需要显示的**安全预签名 URL**。

**验收标准：** 用户可以添加分割线和上传图片，并且它们都能在 A4 画布上被正确渲染、拖动和调整大小。

### **Phase 5.4: “所得” (WYSIWYG PDF Generation)**

**目标：** **修复**在 Phase 5.0 中“弄坏”的 worker 服务，使其 100% 匹配前端预览。

1. **后端 (Worker):**  
   * **彻底重写** backend/internal/worker/pdf\_handler.go。  
2. **后端 (Worker \- 解析):**  
   * ProcessTask 处理器现在从数据库中获取 Resume 记录并解析 Content 字段中的 JSONB 数据。  
3. **后端 (Worker \- Go 模板):**  
   * worker **必须**使用 Go 的 html/template 引擎来渲染一个 HTML 文件。  
   * 此 Go 模板**必须**与前端的 react-grid-layout **100% 匹配**：  
     * **Grid:** grid-template-columns: repeat(24, 1fr); 和 grid-auto-rows: 10px;。  
     * **Items:** range 遍历 items 数组，并为每个 item 动态生成 grid-column 和 grid-row 样式。  
     * **Styles:** 将 layout\_settings（如 accent\_color）注入到 \<style\> 标签中。  
   * **类型渲染：** Go 模板**必须**有 {{if eq .Type "text"}}...{{else if eq .Type "divider"}}...{{else if eq .Type "image"}}...{{end}} 逻辑。  
   * **图片 (关键)：** 对于 image 类型，Go 模板**不能**只使用 src="{{.Content}}"。它**必须**（在 worker 处理器中）为每个 objectKey 调用 storage.Client.GeneratePresignedURL，并将**临时的、安全的 URL** 传递给模板。

**验收标准：** 用户在前端做的**所有**改动（布局、文本、样式、图片、分割线），在点击“下载 PDF”后，生成的 PDF 文件与预览**视觉上 100% 一致**。

### **Phase 5.5: 模板系统 (Save/Import)**

**目标：** 实现“保存和导入模板”功能。

1. **后端 (Database):**  
   * 创建**新**的 GORM 模型 Template (backend/internal/database/models.go)。  
   * Template 结构应包含：Title string, PreviewImageURL string, ContentJSON jsonb (模板的 JSON 内容)。  
2. **后端 (API):**  
   * backend/internal/api/template\_handler.go (新文件)。  
   * 实现**受 AuthMiddleware 保护**的新路由：  
     * GET /v1/templates (获取所有公共/用户模板)。  
     * GET /v1/templates/:id (获取单个模板的 JSON 内容)。  
     * POST /v1/templates (将用户**当前**的简历 JSON 保存为一个新模板)。  
3. **前端 (UI/UX):**  
   * 创建一个 TemplatesPanel.tsx 组件（例如，一个模态框）。  
   * **“导入/应用”：** 当用户点击一个模板时，fetch (GET /v1/templates/:id)，获取其 ContentJSON，并用这个 JSON **完全替换** React JSON 状态。react-grid-layout 会立即重新渲染为新模板。  
   * **“保存”：** 当用户点击“保存当前为模板”时，POST /v1/templates，将**当前** React JSON 状态发送到后端。

**验收标准：** 用户可以应用一个“两栏”模板，然后切换到一个“单栏”模板，并且可以将自己的布局保存为新模板。

## **Phase 6: CI/CD 与生产部署**

**(即原 Phase 5\)**

**目标：** 自动化测试和部署流程，准备好向生产环境（容器+托管）迁移。

1. **CI (持续集成)：**  
   * 创建 .github/workflows/ci.yml。  
   * 触发器：on: push (所有分支)。  
   * Jobs：test-backend (go test), test-frontend (npm test)。  
2. **CD (持续部署)：**  
   * 创建 .github/workflows/deploy.yml。  
   * 触发器：on: push, branches: \[ main \]。  
   * Jobs：  
     1. (Secrets) 配置 ALIYUN\_REGISTRY\_TOKEN, ALIYUN\_OSS\_KEY 等密钥。  
     2. (Build & Push) 登录阿里云镜像仓库 (ACR)，构建 api, worker, frontend 镜像，并推送。  
     3. (Deploy) SSH 登录到你的生产服务器，执行 docker-compose pull 和 docker-compose \-f ... up \-d 来更新服务。  
3. **生产环境准备 (托管)：**  
   * 将 docker-compose.prod.yml 中的 db, redis 替换为阿里云 RDS (PostgreSQL) 和 ApsaraCache (Redis) 的连接字符串。  
   * MinIO 替换为 阿里云 OSS 的生产环境 Bucket 和 Endpoint。  
   * **关键：** MINIO\_PUBLIC\_ENDPOINT 环境变量现在必须设置为你的**生产域名**（例如 https://my-app.com 或 https://cdn.my-app.com）。

**验收标准：** 向 main 分支 git push 一次代码，几分钟后，生产环境的网站自动更新为最新版本。


## **Phase 7: 补充**
1. **存储安全性：**  
   * 用户不应能无限制上传图片  
1. **撤回栈：**  
   * 撤回功能需要合理扩展 