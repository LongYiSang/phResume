# 上云部署步骤（单机 docker compose + 同机自建 DB/Redis + GitHub Actions 自动部署）

> 目标：一台云服务器只对公网暴露 `80/443`，所有业务流量走 Nginx；Postgres/Redis 同机自建（compose 里跑）；对象存储使用托管；推送 `main` 后自动构建镜像并 SSH 部署到服务器。

---

## 0. 你需要准备什么

### 0.1 账号与资源

- GitHub 仓库（默认分支 `main`）
- 一台云服务器（建议 Ubuntu 22.04 LTS）
- 同机自建 Postgres（compose 里跑，使用 volume 持久化）
- 同机自建 Redis（compose 里跑；学习展示用途可接受重启丢数据）
- 对象存储（S3/COS/Cloudflare R2/MinIO 托管等，需 S3 兼容）
- 域名（可选；没有域名也可先用 IP 走 HTTP）

### 0.2 本地工具

- `ssh` / `scp`
- 一个能生成随机密钥的方式（例如 `openssl rand -base64 48`）

---

## 1. 开通云资源（对象存储）+ 明确同机 DB/Redis 策略

### 1.1 Postgres（同机自建）

本项目生产 compose 已内置 `db`（Postgres 15）服务，并使用 `pgdata` volume 持久化数据。

你需要做的只有：
1. 在服务器的 `.env` 配置强随机口令：
   - `POSTGRES_DB`、`POSTGRES_USER`、`POSTGRES_PASSWORD`
2. 连接模式：
   - 同机容器内连接：`DATABASE_HOST=db`、`DATABASE_SSLMODE=disable`
3. 远程管理（你选择映射端口）：
   - `docker-compose.prod.yml` 会把 `5432:5432` 映射到宿主机
   - 请在云安全组 **只放行你的 IP** 的 `5432/tcp`
   - 更安全的替代方案：改为 `127.0.0.1:5432:5432` + SSH Tunnel（推荐）

### 1.2 Redis（同机自建，默认不持久化）

生产 compose 已内置 `redis` 服务，默认仅容器网络可访问（不对外暴露端口）。

你选择“接受重启丢队列/锁定数据”，因此：
- 不启用 AOF/RDB（容器重启会丢 Asynq 队列、登录锁/黑名单等状态）
- 对学习展示来说通常可接受；若后续想增强可靠性，再加持久化与备份

### 1.3 对象存储（托管 S3/COS/R2）

1. 创建 Bucket：建议 `resumes`
2. 创建 AccessKey/SecretKey（最小权限：只允许该 bucket 的读写/签名）
3. 确定两个端点：
   - `MINIO_ENDPOINT`：给后端 SDK 用的 endpoint（通常 **不带 scheme**，例如 `s3.ap-southeast-1.amazonaws.com` 或 `xxx.r2.cloudflarestorage.com`）
   - `MINIO_PUBLIC_ENDPOINT`：给浏览器访问预签名 URL 的公网 endpoint（必须是 **带 scheme 的 URL**，例如 `https://assets.example.com` 或 `https://bucket.s3....`）
4. 确定 region 与 bucket 路由：
   - `MINIO_REGION`：例如 `ap-southeast-1`
   - `MINIO_BUCKET_LOOKUP`：`auto|dns|path`（若你用自定义域名/CDN，很多时候需要 `path`）
5. Bucket 是否自动创建：
   - 托管对象存储通常不允许/不建议应用自动创建 bucket：设置 `MINIO_AUTO_CREATE_BUCKET=false`，并手动创建好 bucket。

---

## 2. 创建云服务器与安全组/防火墙

### 2.1 安全组（云平台侧）

- 入站放行：
  - `80/tcp`（HTTP）
  - `443/tcp`（HTTPS，域名就绪后使用）
  - `22/tcp`（SSH：强烈建议只放行你自己的 IP）
- （可选）`5432/tcp`（如果你要远程管理 Postgres：只放行你的 IP）
- Redis 不要对公网开放

### 2.2 服务器侧防火墙（可选但建议）

在服务器上可以启用 UFW：

```bash
sudo ufw allow 22/tcp
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable
sudo ufw status
```

---

## 3. 服务器初始化（Docker + 部署目录）

### 3.1 安装 Docker 与 compose 插件

按 Docker 官方文档安装，装完后确认：

```bash
docker --version
docker compose version
```

### 3.2 创建部署目录

建议固定路径：`/opt/phresume`

```bash
sudo mkdir -p /opt/phresume/deploy/nginx
sudo chown -R $USER:$USER /opt/phresume
```

### 3.3 在服务器创建运行时 `.env`

在仓库根目录有示例：`.env.prod.example`。在服务器创建 `/opt/phresume/.env`：

```bash
cd /opt/phresume
nano .env
```

至少要配置（全部为必填或强烈建议项）：
- `GHCR_OWNER`
- `POSTGRES_DB`、`POSTGRES_USER`、`POSTGRES_PASSWORD`
- `MINIO_ENDPOINT`、`MINIO_PUBLIC_ENDPOINT`、`MINIO_ACCESS_KEY_ID`、`MINIO_SECRET_ACCESS_KEY`、`MINIO_USE_SSL`、`MINIO_BUCKET`、`MINIO_REGION`、`MINIO_BUCKET_LOOKUP`、`MINIO_AUTO_CREATE_BUCKET`
- `INTERNAL_API_SECRET`（强随机）
- `JWT_PRIVATE_KEY`、`JWT_PUBLIC_KEY`（Base64 PEM）

可选项：
- `API_COOKIE_DOMAIN`（你有域名后再设置）
- `API_ALLOWED_ORIGINS`（跨域/多域名部署才需要）

### 3.4（可选）服务器登录 GHCR

如果你的 GHCR 镜像是私有的，服务器需要能 `docker pull`：

```bash
docker login ghcr.io
```

用一个 PAT（至少 `read:packages`）登录一次即可（会写入服务器的 docker config）。

---

## 4. 本项目的“生产 compose / Nginx”文件

仓库已提供生产文件：
- `docker-compose.prod.yml`
- `deploy/nginx/nginx.prod.conf`

`docker-compose.prod.yml` 默认只对外暴露 Nginx 80 端口，API/Frontend 都只 `expose` 在容器网络内（减少攻击面）。

---

## 5. 首次手动启动（建议做一次）

先在服务器把这两个文件放到 `/opt/phresume`（CD 流水线后续也会自动覆盖更新）：

```bash
cd /opt/phresume
# 把 docker-compose.prod.yml、deploy/nginx/nginx.prod.conf 拷贝到这里
```

启动：

```bash
cd /opt/phresume
export GHCR_OWNER="$(grep -E '^GHCR_OWNER=' .env | cut -d= -f2-)"
export APP_VERSION=latest
docker compose -f docker-compose.prod.yml up -d
docker compose -f docker-compose.prod.yml ps
```

验证：
- 打开 `http://你的服务器IP/`（前端）
- 打开 `http://你的服务器IP/api/health`（应返回 `{"status":"ok"}`）

---

## 6. 配置 GitHub Actions（CI/CD）

仓库已提供：
- CI：`.github/workflows/ci.yml`
- CD：`.github/workflows/deploy.yml`

### 6.1 在服务器准备 SSH 免密登录

在本地生成一对专用 key（建议独立于你个人 key）：

```bash
ssh-keygen -t ed25519 -C "phresume-deploy" -f ./phresume_deploy_key
```

把公钥追加到服务器（假设你用 `ubuntu` 用户登录）：

```bash
ssh-copy-id -i ./phresume_deploy_key.pub ubuntu@你的服务器IP
```

（或手动把 `phresume_deploy_key.pub` 内容追加到 `~/.ssh/authorized_keys`）

### 6.2 在 GitHub 仓库配置 Secrets

进入 GitHub → Repo → Settings → Secrets and variables → Actions，新增：

- `SSH_HOST`：服务器公网 IP（或域名）
- `SSH_USER`：SSH 用户名（如 `ubuntu`）
- `SSH_PRIVATE_KEY`：`phresume_deploy_key` 的私钥内容
- 可选 `SSH_PORT`：默认 22
- 可选 `DEPLOY_PATH`：默认 `/opt/phresume`

### 6.3 触发自动部署

将代码 push 到 `main`：

```bash
git push origin main
```

在 GitHub Actions 页面观察：
1. `Deploy` workflow：build&push 三个镜像到 GHCR
2. 然后通过 SSH 上传 `docker-compose.prod.yml` 与 `nginx.prod.conf` 并执行：
   - `docker compose pull`
   - `docker compose up -d --remove-orphans`

---

## 7. 域名与 HTTPS（域名就绪后再做）

### 7.1 DNS

在你的主域名下添加一个子域名 A 记录：
- `resume.example.com` → 你的服务器公网 IP

等待 DNS 生效后，再继续。

### 7.2 HTTPS（建议用 Let's Encrypt）

由于当前 Nginx 运行在容器内，常见做法是：
1. 在宿主机上申请证书（certbot）
2. 把证书目录挂载进 Nginx 容器
3. 修改 `deploy/nginx/nginx.prod.conf` 支持 443 + 80→443 跳转

这一步涉及“额外的 Nginx/compose 改动”，建议你域名确认后我再按你选择的方案（certbot/Cloudflare/其他）把配置补齐。

同时建议你设置：
- `API_COOKIE_DOMAIN=.example.com`（如果你希望未来多个子域共享 Cookie；只用单子域也可以不设置）

---

## 8. 日常运维（最常用命令）

在服务器上：

```bash
cd /opt/phresume
docker compose -f docker-compose.prod.yml ps
docker compose -f docker-compose.prod.yml logs -f --tail=200
docker compose -f docker-compose.prod.yml pull
docker compose -f docker-compose.prod.yml up -d --remove-orphans
```

回滚（把 `APP_VERSION` 改成某个历史 commit SHA 对应的镜像 tag）：

```bash
cd /opt/phresume
export GHCR_OWNER=YOUR_GITHUB_ORG_OR_USER
export APP_VERSION=某个历史SHA
docker compose -f docker-compose.prod.yml pull
docker compose -f docker-compose.prod.yml up -d --remove-orphans
```

---

## 9. 常见问题（上云前先看这里）

### 9.1 Postgres 暴露 5432 的风险

你选择了 `5432:5432` 映射用于远程管理，请至少做到：
- 云安全组只放行你的固定 IP
- 强随机 `POSTGRES_PASSWORD`
- 及时更新镜像与系统补丁

更推荐做法：只绑定到 `127.0.0.1` 并用 SSH Tunnel 管理。

### 9.2 预签名 URL 打不开 / 指向内网

请确保：
- `MINIO_PUBLIC_ENDPOINT` 是浏览器能访问的 HTTPS 域名（不要是内网地址）
- 服务器时间准确（建议开启 NTP），否则预签名会因为时钟偏差失效

### 9.3 Worker PDF 生成失败

检查：
- `WORKER_FRONTEND_BASE_URL` 在 **容器网络内**能访问（默认 `http://frontend:3000`）
- `INTERNAL_API_SECRET` 是否正确（Worker 需要用它访问内部打印接口）
- 云服务器 CPU/内存是否足够（Chromium 渲染很吃资源，`WORKER_CONCURRENCY` 不要太大）
